# shellcheck shell=bash
# Simplified Development workflow functions for LOCAL DEVELOPMENT ONLY
# Simplified security model focused on usability and basic safety

git-export() {
    # Description: Clone a git repository without git history (export for templates)
    # Usage: git-export REPO_URL [TARGET_DIR]
    # Example: git-export https://github.com/user/repo.git my-project
    if [ $# -eq 0 ]; then
        echo "Usage: git-export REPO_URL [TARGET_DIR]"
        echo "Example: git-export https://github.com/user/repo.git my-project"
        return 1
    fi

    local repo_url="$1"
    local target_dir="$2"

    # If no target directory specified, derive from repo URL
    if [ -z "$target_dir" ]; then
        target_dir=$(basename "$repo_url" .git)
    fi

    if [ -d "$target_dir" ]; then
        echo "Error: Directory '$target_dir' already exists"
        return 1
    fi

    echo "Exporting repository to $target_dir..."

    # Clone with minimal depth and remove .git directory
    if git clone --depth 1 "$repo_url" "$target_dir"; then
        rm -rf "$target_dir/.git"
        echo "Repository exported successfully to $target_dir"
        echo "Git history has been removed - this is now a clean template"
    else
        echo "Failed to clone repository"
        return 1
    fi
}

create-project() {
    # Description: Create a new project directory with basic structure
    # Usage: create-project PROJECT_NAME [TEMPLATE_TYPE]
    # Example: create-project my-app node
    if [ $# -eq 0 ]; then
        echo "Usage: create-project PROJECT_NAME [TEMPLATE_TYPE]"
        echo "Template types: node, python, rust, go, simple"
        return 1
    fi

    local project_name="$1"
    local template_type="${2:-simple}"

    if [ -d "$project_name" ]; then
        echo "Error: Directory '$project_name' already exists"
        return 1
    fi

    echo "Creating project: $project_name (type: $template_type)"
    mkdir -p "$project_name"
    cd "$project_name" || return 1

    # Create basic structure
    case "$template_type" in
        "node")
            echo "Creating Node.js project structure..."
            mkdir -p src tests docs
            cat >package.json <<'EOF'
{
  "name": "",
  "version": "1.0.0",
  "description": "",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "MIT"
}
EOF
            echo 'console.log("Hello, World!");' >src/index.js
            echo "node_modules/" >.gitignore
            echo "*.log" >>.gitignore
            ;;
        "python")
            echo "Creating Python project structure..."
            mkdir -p src tests docs
            cat >requirements.txt <<'EOF'
# Add your dependencies here
EOF
            echo 'print("Hello, World!")' >src/main.py
            cat >.gitignore <<'EOF'
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.git
.mypy_cache
.pytest_cache
.hypothesis
EOF
            ;;
        "rust")
            echo "Creating Rust project structure..."
            if command -v cargo >/dev/null 2>&1; then
                cargo init --name "$project_name" .
            else
                mkdir -p src
                cat >Cargo.toml <<EOF
[package]
name = "$project_name"
version = "0.1.0"
edition = "2021"

[dependencies]
EOF
                echo 'fn main() { println!("Hello, World!"); }' >src/main.rs
                cat >.gitignore <<'EOF'
target/
Cargo.lock
EOF
            fi
            ;;
        "go")
            echo "Creating Go project structure..."
            mkdir -p cmd pkg internal
            cat >go.mod <<EOF
module $project_name

go 1.19
EOF
            cat >cmd/main.go <<'EOF'
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
EOF
            echo "*.exe" >.gitignore
            echo "$project_name" >>.gitignore
            ;;
        "simple" | *)
            echo "Creating simple project structure..."
            mkdir -p src docs
            echo "# $project_name" >README.md
            echo "" >src/.gitkeep
            echo "" >docs/.gitkeep
            ;;
    esac

    # Common files for all projects
    cat >README.md <<EOF
# $project_name

## Description
[Add your project description here]

## Installation
[Add installation instructions here]

## Usage
[Add usage instructions here]

## License
[Add license information here]
EOF

    cat >.editorconfig <<'EOF'
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
indent_style = space
indent_size = 2

[*.py]
indent_size = 4

[*.go]
indent_style = tab
EOF

    # Initialize git repository if git is available
    if command -v git >/dev/null 2>&1; then
        git init
        git add .
        git commit -m "Initial commit: $template_type project structure"
        echo "Git repository initialized"
    fi

    echo "Project '$project_name' created successfully!"
    echo "Location: $(pwd)"
}

quick-server() {
    # Description: Start a quick HTTP server for local development
    # Usage: quick-server [PORT] [DIRECTORY]
    # Example: quick-server 8080 ./public
    local port="${1:-8000}"
    local directory="${2:-.}"

    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1024 ] || [ "$port" -gt 65535 ]; then
        echo "Error: PORT must be a number between 1024 and 65535"
        return 1
    fi

    if [ ! -d "$directory" ]; then
        echo "Error: Directory '$directory' does not exist"
        return 1
    fi

    echo "Starting HTTP server on port $port serving $directory"
    echo "Access at: http://localhost:$port"
    echo "Press Ctrl+C to stop"

    # Try different server options in order of preference
    if command -v python3 >/dev/null 2>&1; then
        cd "$directory" && python3 -m http.server "$port"
    elif command -v python >/dev/null 2>&1; then
        cd "$directory" && python -m SimpleHTTPServer "$port"
    elif command -v node >/dev/null 2>&1; then
        # Create a simple Node.js server
        node -e "
        const http = require('http');
        const fs = require('fs');
        const path = require('path');
        const server = http.createServer((req, res) => {
            let filePath = path.join('$directory', req.url === '/' ? 'index.html' : req.url);
            fs.readFile(filePath, (err, content) => {
                if (err) {
                    res.writeHead(404);
                    res.end('File not found');
                } else {
                    res.writeHead(200);
                    res.end(content);
                }
            });
        });
        server.listen($port, () => console.log('Server running on port $port'));
        "
    elif command -v ruby >/dev/null 2>&1; then
        cd "$directory" && ruby -run -e httpd . -p "$port"
    elif command -v php >/dev/null 2>&1; then
        cd "$directory" && php -S "localhost:$port"
    else
        echo "No suitable HTTP server found (python, node, ruby, or php required)"
        return 1
    fi
}

test-api() {
    # Description: Quick API endpoint testing with curl
    # Usage: test-api METHOD URL [DATA]
    # Example: test-api GET https://api.example.com/users
    if [ $# -lt 2 ]; then
        echo "Usage: test-api METHOD URL [DATA]"
        echo "Methods: GET, POST, PUT, DELETE, PATCH"
        echo "Example: test-api GET https://api.example.com/users"
        echo "Example: test-api POST https://api.example.com/users '{\"name\":\"John\"}'"
        return 1
    fi

    local method="$1"
    local url="$2"
    local data="${3:-}"

    # Validate HTTP method
    case "$method" in
        GET | POST | PUT | DELETE | PATCH | HEAD | OPTIONS) ;;
        *)
            echo "Error: Invalid HTTP method '$method'"
            echo "Valid methods: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS"
            return 1
            ;;
    esac

    echo "Testing API endpoint..."
    echo "Method: $method"
    echo "URL: $url"
    if [ -n "$data" ]; then
        echo "Data: $data"
    fi
    echo "----------------------------------------"

    local curl_args=(-X "$method" -v)

    if [ -n "$data" ]; then
        curl_args+=(-H "Content-Type: application/json")
        curl_args+=(-d "$data")
    fi

    curl_args+=("$url")

    curl "${curl_args[@]}"
    echo
}

docker-clean() {
    # Description: Clean up Docker resources (containers, images, volumes)
    # Usage: docker-clean [--all]
    # Example: docker-clean or docker-clean --all
    if ! command -v docker >/dev/null 2>&1; then
        echo "Docker is not installed or not in PATH"
        return 1
    fi

    local clean_all=false
    if [ "$1" = "--all" ]; then
        clean_all=true
    fi

    echo "Docker cleanup starting..."

    # Stop all running containers
    local running_containers
    running_containers=$(docker ps -q)
    if [ -n "$running_containers" ]; then
        echo "Stopping running containers..."
        docker stop "$running_containers"
    fi

    # Remove stopped containers
    local stopped_containers
    stopped_containers=$(docker ps -a -q)
    if [ -n "$stopped_containers" ]; then
        echo "Removing stopped containers..."
        docker rm "$stopped_containers"
    fi

    # Remove dangling images
    local dangling_images
    dangling_images=$(docker images -f "dangling=true" -q)
    if [ -n "$dangling_images" ]; then
        echo "Removing dangling images..."
        docker rmi "$dangling_images"
    fi

    if [ "$clean_all" = true ]; then
        echo "Performing aggressive cleanup..."

        # Remove all unused images (not just dangling)
        docker image prune -a -f

        # Remove all unused volumes
        docker volume prune -f

        # Remove all unused networks
        docker network prune -f

        # Remove build cache
        docker builder prune -f
    else
        echo "Performing standard cleanup..."
        docker system prune -f
    fi

    echo "Docker cleanup completed!"
    echo "Current usage:"
    docker system df
}

generate-env() {
    # Description: Generate a .env file template for a project
    # Usage: generate-env [PROJECT_TYPE]
    # Example: generate-env node
    local project_type="${1:-generic}"
    local env_file=".env"

    if [ -f "$env_file" ]; then
        echo "Warning: $env_file already exists"
        printf "Overwrite? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled"
            return 1
        fi
    fi

    echo "Generating $env_file template for $project_type project..."

    case "$project_type" in
        "node" | "nodejs")
            cat >"$env_file" <<'EOF'
# Node.js Environment Variables
NODE_ENV=development
PORT=3000

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=postgres
DB_PASS=

# Redis (if used)
REDIS_URL=redis://localhost:6379

# API Keys
API_KEY=
JWT_SECRET=

# External Services
# STRIPE_SECRET_KEY=
# SENDGRID_API_KEY=
EOF
            ;;
        "python" | "django" | "flask")
            cat >"$env_file" <<'EOF'
# Python Environment Variables
DEBUG=True
SECRET_KEY=your-secret-key-here

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# Redis (if used)
REDIS_URL=redis://localhost:6379/0

# Email
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_HOST_USER=
EMAIL_HOST_PASSWORD=

# API Keys
# STRIPE_SECRET_KEY=
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
EOF
            ;;
        "rust")
            cat >"$env_file" <<'EOF'
# Rust Environment Variables
RUST_LOG=debug
PORT=8080

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# Redis (if used)
REDIS_URL=redis://localhost:6379

# API Keys
API_KEY=
EOF
            ;;
        "go" | "golang")
            cat >"$env_file" <<'EOF'
# Go Environment Variables
GO_ENV=development
PORT=8080

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=postgres
DB_PASS=

# Redis (if used)
REDIS_ADDR=localhost:6379

# API Keys
API_KEY=
JWT_SECRET=
EOF
            ;;
        *)
            cat >"$env_file" <<'EOF'
# Generic Environment Variables
ENV=development
PORT=8000

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=user
DB_PASS=password

# Cache
CACHE_URL=redis://localhost:6379

# Security
SECRET_KEY=change-me-in-production
JWT_SECRET=change-me-in-production

# API Keys (uncomment and fill as needed)
# API_KEY=
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
# STRIPE_SECRET_KEY=
# SENDGRID_API_KEY=

# External Services
# SENTRY_DSN=
# ROLLBAR_ACCESS_TOKEN=
EOF
            ;;
    esac

    # Create .env.example as well
    cp "$env_file" ".env.example"

    # Add .env to .gitignore if it exists
    if [ -f ".gitignore" ]; then
        if ! grep -q "^\.env$" .gitignore; then
            echo ".env" >>.gitignore
            echo "Added .env to .gitignore"
        fi
    else
        echo ".env" >.gitignore
        echo "Created .gitignore with .gitignore"
    fi

    echo "Generated $env_file and .env.example"
    echo "Remember to:"
    echo "1. Fill in actual values in $env_file"
    echo "2. Never commit $env_file to version control"
    echo "3. Keep .env.example up to date for team members"
}
