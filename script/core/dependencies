#!/usr/bin/env bash

# Source common utilities
source "$(dirname "${BASH_SOURCE[0]}")/common"

# ============================================================================
# Package Installation
# ============================================================================

ensure_dependencies() {
	process_brewfile "dependencies/dependencies.brewfile" "Installing Core Dependencies"
}

ensure_applications() {
	process_brewfile "dependencies/applications.brewfile" "Installing Applications"
}

# ============================================================================
# Development Environment Setup
# ============================================================================

# Source asdf environment
source_asdf_env() {
	# Source asdf to ensure it's available in PATH
	if [ -f "$HOME/.asdf/asdf.sh" ]; then
		source "$HOME/.asdf/asdf.sh"
	else
		local asdf_prefix
		asdf_prefix=$(brew --prefix asdf 2>/dev/null)
		if [ -f "$asdf_prefix/libexec/asdf.sh" ]; then
			source "$asdf_prefix/libexec/asdf.sh"
		fi
	fi
}

# Wait for npm to be available after asdf Node.js setup with retry logic
wait_for_npm_availability() {
	local max_retries=10
	local retry_interval=2
	local retry_count=0
	
	info_log "Checking npm availability after Node.js installation..."
	
	while [ "$retry_count" -lt "$max_retries" ]; do
		# Re-source asdf environment and reshim
		source_asdf_env
		silent "asdf reshim nodejs" 2>/dev/null || true
		
		# Check if npm is now available
		if command -v npm >/dev/null 2>&1; then
			success_log "npm is now available"
			return 0
		fi
		
		retry_count=$((retry_count + 1))
		info_log "npm not yet available, retrying in ${retry_interval}s... (attempt $retry_count/$max_retries)"
		sleep "$retry_interval"
	done
	
	error_log "npm is not available after $max_retries attempts"
	return 1
}

# Install or update asdf plugins and versions
setup_asdf_tools() {
	local is_update_mode="${1:-false}"
	
	if ! check_command "asdf" "asdf version manager"; then
		warn_log "asdf not found, skipping language version management"
		return 1
	fi
	
	# Source asdf environment first
	source_asdf_env
	
	# Add plugins (skip if already exist)
	for plugin in ruby python nodejs golang; do
		if ! asdf plugin list | grep -q "^${plugin}$"; then
			info_log "Adding asdf plugin: $plugin"
			if silent "asdf plugin add $plugin"; then
				# Verify plugin was actually installed
				if asdf plugin list | grep -q "^${plugin}$"; then
					success_log "Successfully added asdf plugin: $plugin"
				else
					error_log "Plugin $plugin was not installed correctly"
					continue
				fi
			else
				error_log "Failed to add asdf plugin: $plugin"
				continue
			fi
		else
			info_log "asdf plugin $plugin already installed"
		fi
	done
	
	# Update plugin repositories to get latest versions
	silent "asdf plugin update --all" || true
	
	# Install and set latest stable versions
	for tool in ruby python nodejs golang; do
		info_log "Processing $tool..."
		
		# Get latest stable version
		local latest_version
		latest_version=$(asdf latest "$tool" 2>/dev/null) || {
			error_log "Could not determine latest stable version for $tool"
			continue
		}
		
		if [ -n "$latest_version" ]; then
			# Check if this version is already installed
			if ! asdf list "$tool" 2>/dev/null | grep -q "$latest_version"; then
				info_log "Installing $tool $latest_version..."
				if silent "asdf install $tool $latest_version"; then
					success_log "Successfully installed $tool $latest_version"
					
					# Verify installation
					if ! asdf list "$tool" 2>/dev/null | grep -q "$latest_version"; then
						error_log "$tool $latest_version installation failed verification"
						continue
					fi
				else
					error_log "Failed to install $tool $latest_version"
					continue
				fi
			else
				info_log "$tool $latest_version already installed"
			fi
			
			# Install the version but don't try to set it globally here
			# The global ~/.tool-versions will be updated by update_tool_versions_file()
			info_log "Version $tool $latest_version is ready for global use"
			
			# Clean up old versions if in update mode
			if [ "$is_update_mode" = "true" ]; then
				cleanup_old_asdf_versions "$tool" "$latest_version"
			fi
		fi
	done
	
	# Reshim all tools to ensure executables are available
	info_log "Refreshing asdf shims..."
	if silent "asdf reshim"; then
		success_log "asdf shims refreshed successfully"
	else
		error_log "Failed to refresh asdf shims"
		return 1
	fi
	
	# Update ~/.tool-versions file with latest versions
	update_tool_versions_file
}

# Update ~/.tool-versions file with current global versions
update_tool_versions_file() {
	local tool_versions_file="$HOME/.tool-versions"
	
	info_log "Updating $tool_versions_file with latest versions..."
	
	# Create or clear the file
	> "$tool_versions_file"
	
	# Add each tool's latest version to the file
	for tool in ruby python nodejs golang; do
		local version=""
		
		# First, try to get the latest installed version
		local installed_versions
		installed_versions=$(asdf list "$tool" 2>/dev/null | tail -1 | sed 's/^[[:space:]]*//')
		
		if [ -n "$installed_versions" ] && [ "$installed_versions" != "No versions installed" ]; then
			# Use the last (usually latest) installed version
			version="$installed_versions"
			info_log "Using installed version for $tool: $version"
		else
			# No installed version, get the latest available
			info_log "No installed version for $tool, fetching latest..."
			version=$(asdf latest "$tool" 2>/dev/null)
			
			if [ -n "$version" ]; then
				info_log "Latest version for $tool is $version"
			fi
		fi
		
		# Add to .tool-versions if we have a valid version
		if [ -n "$version" ] && [ "$version" != "No" ] && [ "$version" != "Version" ]; then
			echo "$tool $version" >> "$tool_versions_file"
			success_log "Added $tool $version to .tool-versions"
		else
			warn_log "Could not determine version for $tool"
			# Try to at least add the latest version as fallback
			local fallback_version
			fallback_version=$(asdf latest "$tool" 2>/dev/null)
			if [ -n "$fallback_version" ]; then
				echo "$tool $fallback_version" >> "$tool_versions_file"
				success_log "Added $tool $fallback_version to .tool-versions (fallback)"
			fi
		fi
	done
	
	# Verify the file was created and has content
	if [ -f "$tool_versions_file" ] && [ -s "$tool_versions_file" ]; then
		success_log "Successfully updated $tool_versions_file"
		info_log "Contents:"
		while IFS= read -r line; do
			info_log "  $line"
		done < "$tool_versions_file"
	else
		error_log "Failed to create $tool_versions_file or file is empty"
		return 1
	fi
}

# Clean up old asdf versions with safety checks and confirmation
cleanup_old_asdf_versions() {
	local tool="$1"
	local latest_version="$2"
	
	# Safety check: ensure we have a valid latest version
	if [ -z "$latest_version" ]; then
		error_log "Cannot cleanup versions: latest_version is empty for $tool"
		return 1
	fi
	
	# Safety check: ensure latest version is actually installed
	if ! asdf list "$tool" 2>/dev/null | grep -q "^[[:space:]]*$latest_version$"; then
		error_log "Cannot cleanup versions: latest version $latest_version is not installed for $tool"
		return 1
	fi
	
	local installed_versions
	installed_versions=$(asdf list "$tool" 2>/dev/null | grep -v '\*' | sed 's/^[[:space:]]*//' | grep -v "^$latest_version$") || return 0
	
	if [ -z "$installed_versions" ]; then
		info_log "No old versions of $tool to clean up"
		return 0
	fi
	
	# Display versions that will be removed
	info_log "Found old versions of $tool that can be removed:"
	echo "$installed_versions" | while read -r version; do
		if [ -n "$version" ]; then
			info_log "  - $version"
		fi
	done
	
	info_log "Current version: $latest_version (will be kept)"
	
	# Interactive confirmation for safety
	if [ "${DOTFILES_AUTO_CLEANUP:-false}" != "true" ]; then
		info_log "Cleanup can be automated by setting DOTFILES_AUTO_CLEANUP=true"
		return 0
	fi
	
	# Proceed with cleanup
	echo "$installed_versions" | while read -r version; do
		if [ -n "$version" ] && [ "$version" != "$latest_version" ]; then
			info_log "Removing old $tool version: $version"
			if silent "asdf uninstall $tool $version"; then
				success_log "Successfully removed $tool $version"
			else
				error_log "Failed to remove $tool $version"
			fi
		fi
	done
}

ensure_development() {
	setup_homebrew_env
	
	# Setup asdf tools (first install mode)
	setup_asdf_tools "false"

	if check_command "rustup" "Rust toolchain manager"; then
		if ! silent "rustup toolchain list | grep -q stable"; then
			info_log "Installing Rust stable toolchain..."
			silent "rustup install stable" || true
		else
			info_log "Rust stable toolchain is already installed"
		fi
		
		if ! silent "rustup toolchain list | grep -q nightly"; then
			info_log "Installing Rust nightly toolchain..."
			silent "rustup install nightly" || true
		else
			info_log "Rust nightly toolchain is already installed"
		fi
		
		silent "rustup default stable" || true
		
		# Install cargo packages from dependencies file
		process_package_file \
			"${DOTFILES_PARENT_DIR:-$PWD}/dependencies/cargo.packages" \
			"cargo" \
			"silent \"cargo install {}\"" \
			"cargo install --list | grep -q '^{} v'" \
			"Rust cargo packages"
	fi
	
	# Install npm packages from dependencies file
	# First ensure asdf environment is loaded and npm is available
	if check_command "asdf" "asdf version manager"; then
		# Wait for npm to be available after Node.js installation
		if wait_for_npm_availability; then
			process_package_file \
				"${DOTFILES_PARENT_DIR:-$PWD}/dependencies/npm.packages" \
				"npm" \
				"silent \"npm install -g {}\"" \
				"npm list -g {} >/dev/null 2>&1" \
				"Node.js npm packages"
		else
			error_log "npm is not available. Skipping npm package installation."
		fi
	else
		warn_log "asdf not found. Skipping npm package installation."
	fi
}

# ============================================================================
# Maintenance
# ============================================================================

ensure_updated() {
	silent "brew upgrade"
	silent "mas upgrade"
}

# Update development environment with cleanup
update_development() {
	setup_homebrew_env
	
	# Setup asdf tools (update mode with cleanup)
	# This will also call update_tool_versions_file internally
	setup_asdf_tools "true"
	
	if check_command "rustup" "Rust toolchain manager"; then
		info_log "Updating Rust toolchains..."
		silent "rustup update" || true
		
		# Install cargo packages from dependencies file
		process_package_file \
			"${DOTFILES_PARENT_DIR:-$PWD}/dependencies/cargo.packages" \
			"cargo" \
			"silent \"cargo install {}\"" \
			"cargo install --list | grep -q '^{} v'" \
			"Rust cargo packages"
	fi
	
	# Install npm packages from dependencies file
	if check_command "asdf" "asdf version manager"; then
		# Wait for npm to be available after Node.js updates
		if wait_for_npm_availability; then
			process_package_file \
				"${DOTFILES_PARENT_DIR:-$PWD}/dependencies/npm.packages" \
				"npm" \
				"silent \"npm install -g {}\"" \
				"npm list -g {} >/dev/null 2>&1" \
				"Node.js npm packages"
		else
			error_log "npm is not available. Skipping npm package installation."
		fi
	else
		warn_log "asdf not found. Skipping npm package installation."
	fi
}