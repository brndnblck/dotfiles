#!/usr/bin/env bash
source "$(dirname "${BASH_SOURCE[0]}")/ansi"


source "$(dirname "${BASH_SOURCE[0]}")/logging"
source "$(dirname "${BASH_SOURCE[0]}")/validation"
source "$(dirname "${BASH_SOURCE[0]}")/execution"
source "$(dirname "${BASH_SOURCE[0]}")/errors"


TEMP_FILES_FOR_CLEANUP=()

add_temp_file_cleanup() {
    local file="$1"
    TEMP_FILES_FOR_CLEANUP+=("$file")

    if [ ${#TEMP_FILES_FOR_CLEANUP[@]} -eq 1 ]; then
        trap 'cleanup_temp_files' EXIT INT TERM
    fi
}

cleanup_temp_files() {
    for file in "${TEMP_FILES_FOR_CLEANUP[@]}"; do
        if [ -f "$file" ]; then
            rm -f "$file" 2>/dev/null || true
            info_log "Cleaned up temp file: $file"
        fi
    done
    TEMP_FILES_FOR_CLEANUP=()
}



process_template() {
    local template_file="$1"
    local output_file="$2"
    local cleanup_temp="${3:-true}"
    local fallback_enabled="${4:-true}"
    
    if ! check_file_exists "$template_file" "Template file"; then
        return 1
    fi
    
    # Add file to cleanup list if it's a temp file
    if [ "$cleanup_temp" = "true" ] && echo "$output_file" | grep -q "^/tmp/"; then
        add_temp_file_cleanup "$output_file"
    fi
    

    if check_command "chezmoi" "Chezmoi"; then
        if chezmoi execute-template < "$template_file" > "$output_file" 2>/dev/null; then
            success_log "Template processed with chezmoi: $template_file -> $output_file"
            return 0
        else
            warn_log "Chezmoi template processing failed, attempting fallback"
        fi
    else
        warn_log "Chezmoi not available, using fallback template processing"
    fi
    

    if [ "$fallback_enabled" = "true" ]; then
        if process_template_fallback "$template_file" "$output_file"; then
            success_log "Template processed with fallback: $template_file -> $output_file"
            return 0
        fi
    fi
    
    template_error "$template_file" "false"

    rm -f "$output_file" 2>/dev/null || true
            return "$EXIT_GENERAL_ERROR"
}

process_template_fallback() {
    local template_file="$1"
    local output_file="$2"
    

    if cp "$template_file" "$output_file" 2>/dev/null; then

        sed -i.bak \
            -e "s/{{ \.user }}/${USER:-unknown}/g" \
            -e "s/{{ now\.Format \"[^\"]*\" }}/$(date '+%Y-%m-%d')/g" \
            -e "s/{{ \.chezmoi\.hostname }}/$(hostname)/g" \
            -e "s/{{ \.chezmoi\.os }}/$(uname -s | tr '[:upper:]' '[:lower:]')/g" \
            "$output_file" 2>/dev/null && rm -f "${output_file}.bak"
        
        info_log "Applied basic template substitutions"
        return 0
    fi
    
    return 1
}

# ============================================================================
# System Management
# ============================================================================

prompt_restart() {
    local message="${1:-A restart is recommended to ensure all changes take effect.}"
    
    ansi --newline
    ansi "$message"
    ansi --newline
    read -p "Restart now? (y/N): " restart_choice
    if [[ "$restart_choice" =~ ^[Yy]$ ]]; then
        sudo shutdown -r +1
        ansi --green "System will restart in 1 minute..."
        ansi --newline
    else
        ansi "Remember to restart when convenient to complete the setup."
        ansi --newline
    fi
}

# ============================================================================
# Package Management Helpers
# ============================================================================

# Common setup for package operations
prepare_package_operation() {
    local description="$1"
    info_log "Processing $description..."
    
    # Refresh sudo session before running package operations to avoid second prompt
    if check_file_exists "/tmp/.bootstrap_sudo_authenticated" "sudo auth marker"; then
        if ! silent "sudo -n true"; then
            warn_log "sudo session expired, package installation may prompt for password"
        fi
    fi
}

# Execute package file with cleanup and error handling
execute_package_file() {
    local file_path="$1"
    local command="$2"
    local description="$3"
    local is_temp_file="${4:-false}"
    
    if silent "$command"; then
        success_log "$description completed"
        [ "$is_temp_file" = "true" ] && rm -f "$file_path"
        return 0
    else
        [ "$is_temp_file" = "true" ] && rm -f "$file_path"
        error_log "Failed to install packages from $(basename "$file_path")" "false"
        return 1
    fi
}

# Process templated package file
process_templated_package_file() {
    local source_file="$1"
    local command_template="$2"
    local description="$3"
    
    local temp_file="/tmp/$(basename "$source_file" .tmpl).$$"
    info_log "Using templated $(basename "$source_file")"
    
    if process_template "$source_file" "$temp_file"; then
        local command
        # Replace {FILE} placeholder with actual temp file path
        command=$(echo "$command_template" | sed "s|{FILE}|$temp_file|g")
        execute_package_file "$temp_file" "$command" "$description" "true"
    else
        error_log "Failed to process template" "true"
        return 1
    fi
}

# Process static package file
process_static_package_file() {
    local file_path="$1"
    local command_template="$2"
    local description="$3"
    
    info_log "Using static $(basename "$file_path")"
    local command
    # Replace {FILE} placeholder with actual file path
    command=$(echo "$command_template" | sed "s|{FILE}|$file_path|g")
    execute_package_file "$file_path" "$command" "$description" "false"
}

# ============================================================================
# Package Management
# ============================================================================

process_brewfile() {
    local brewfile_name="$1"
    local description="$2"
    local base_path="${DOTFILES_PARENT_DIR:-$PWD}"
    
    prepare_package_operation "$description"
    
    # Try templated version first
    if check_file_exists "$base_path/${brewfile_name}.tmpl" "Templated Brewfile"; then
        process_templated_package_file "$base_path/${brewfile_name}.tmpl" "brew bundle -d --file=\"{FILE}\"" "$description"
    elif check_file_exists "$base_path/${brewfile_name}" "Static Brewfile"; then
        process_static_package_file "$base_path/${brewfile_name}" "brew bundle -d --file=\"{FILE}\"" "$description"
    else
        error_log "Neither ${brewfile_name}.tmpl nor ${brewfile_name} found" "true"
        return 1
    fi
}

# Process individual package installation
process_individual_package() {
    local package="$1"
    local package_type="$2"
    local install_command="$3"
    local check_command="$4"
    
    # Resolve template placeholders
    local resolved_install_cmd="${install_command//\{\}/$package}"
    local resolved_check_cmd="${check_command//\{\}/$package}"
    
    # Check if package is already installed
    if eval "$resolved_check_cmd" >/dev/null 2>&1; then
        info_log "$package_type package already installed: $package"
        return 0
    else
        info_log "Installing $package_type package: $package"
        if eval "$resolved_install_cmd" || true; then
            return 0
        else
            installation_error "$package_type" "$package" "false"
    return "$EXIT_GENERAL_ERROR"
        fi
    fi
}

# Parse package file and extract valid package names
parse_package_file() {
    local file_path="$1"
    local packages=()
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Extract package name (first word)
        local package=$(echo "$line" | awk '{print $1}')
        [ -n "$package" ] && packages+=("$package")
    done < "$file_path"
    
    printf '%s\n' "${packages[@]}"
}

# Process package file with standard format (comments, empty lines, first word as package)
process_package_file() {
    local file_path="$1"
    local package_type="$2"
    local install_command="$3"
    local check_command="$4"
    local description="${5:-$package_type packages}"
    
    if ! check_file_exists "$file_path" "$description file"; then
        warn_log "$description file not found: $file_path"
        return 1
    fi
    
    prepare_package_operation "$description"
    
    local count=0
    local installed=0
    local packages
    
    # Parse all packages from file
    readarray -t packages < <(parse_package_file "$file_path")
    count=${#packages[@]}
    
    # Process each package
    for package in "${packages[@]}"; do
        if process_individual_package "$package" "$package_type" "$install_command" "$check_command"; then
            installed=$((installed + 1))
        fi
    done
    
    success_log "Processed $description: $installed/$count packages installed"
    return 0
}