#!/usr/bin/env bash

# UI Helper Functions for Consistent Interface Elements

# Source logging functions
source "$(dirname "${BASH_SOURCE[0]}")/logging"

# Show the standard header with BUILD info, divider, and ASCII art
show_standard_header() {
    clear
    
    # Build info at top
    local git_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
    local git_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
    local version_string
    if [ -n "$git_tag" ]; then
        # Extract version number from tag (remove 'v' prefix if present)
        local version_num=$(echo "$git_tag" | sed 's/^v//')
        version_string="v${version_num}.${git_hash}"
    else
        version_string="v.${git_hash}"
    fi
    gum style \
        --foreground "$INTERFACE_SECONDARY" \
        "$INTERFACE_BOLD" \
        ">> BUILD: ${version_string}"
    
    # Top divider
    colored_divider
    
    # ASCII art DOTFILES header
    local title_color="${1:-$INTERFACE_SECONDARY}"
    gum style --foreground "$title_color" << 'EOF'
 _______  .___________.  __________   __          __________     _______.
|       \ |           | /  /   ____||  |        /  /   ____|   /       |
|  .--.  |`---|  |----`/  /|  |__   |  |       /  /|  |__     |   (----`
|  |  |  |    |  |    /  / |   __|  |  |      /  / |   __|     \   \    
|  '--'  |    |  |   /  /  |  |     |  `----./  /  |  |____.----)   |   
|_______/     |__|  /__/   |__|     |_______/__/   |_______|_______/    
                                                                           
EOF
    
    ansi --newline
}

# Show section header with title and divider
show_section_header() {
    local title="$1"
    
    gum style \
        --foreground "$INTERFACE_SECONDARY" \
        "$INTERFACE_BOLD" \
        ">> ${title}"
    
    colored_divider
    ansi --newline
}

# Show completion message with dividers
show_completion() {
    local message="$1"
    
    ansi --newline
    gum style \
        --foreground "$INTERFACE_SECONDARY" \
        "$INTERFACE_BOLD" \
        --align center \
        ">> ${message}"
    
    colored_divider
}

# Show footer with return prompt
show_footer_prompt() {
    # Wait for user input with blinking cursor on prompt
    ansi --newline
    gum input --placeholder "" \
        --cursor.foreground "$INTERFACE_COLOR" \
        --prompt.foreground "$INTERFACE_SECONDARY" \
        --prompt "▶ PRESS ENTER TO RETURN TO COMMAND INTERFACE "
}

# Simple progressive task tracker
COMPLETED_TASKS=()

# Execute command with simple progressive display
run_with_progressive_spinner() {
    local message="$1"
    shift
    local command="$*"
    
    info_log "Starting: $message"
    
    # Log command to debug file
    debug_log "COMMAND: $command"
    
    # Show the current task with animated spinner in amber
    if gum spin --spinner dot --title " $message" \
        --spinner.foreground "$INTERFACE_COLOR" \
        --title.foreground "$INTERFACE_COLOR" \
        -- bash -c "$command >> '${DOTFILES_LOG_FILE:-/tmp/bootstrap.log}' 2>&1"; then
        
        # Add to completed tasks
        COMPLETED_TASKS+=("$message")
        
        # Show the completed task (gum spin clears its line, so we just print the checkmark)
        echo "░ ✓ $message"
        
        # Also capture command output to debug log
        debug_log "COMMAND OUTPUT:"
        tail -n 50 "${DOTFILES_LOG_FILE:-/tmp/bootstrap.log}" >> "$(get_debug_log_file)"
        debug_log "END COMMAND OUTPUT"
        
        info_log "Completed: $message"
        return 0
    else
        # Log failure details to debug log
        debug_log "COMMAND FAILED: $command"
        debug_log "ERROR OUTPUT:"
        tail -n 50 "${DOTFILES_LOG_FILE:-/tmp/bootstrap.log}" >> "$(get_debug_log_file)"
        debug_log "END ERROR OUTPUT"
        
        error_log "Failed: $message"
        return 1
    fi
}

# Execute command with simple spinner (for status and other scripts)
run_with_spinner() {
    local message="$1"
    shift
    local command="$*"
    
    info_log "Starting: $message"
    
    # Log command to debug file
    debug_log "COMMAND: $command"
    
    if gum spin --spinner dot --title " $message" \
        --spinner.foreground "$INTERFACE_COLOR" \
        --title.foreground "$INTERFACE_COLOR" \
        -- bash -c "$command >> '${DOTFILES_LOG_FILE:-/tmp/bootstrap.log}' 2>&1; echo \$? > /tmp/exit_code_\$\$"; then
        
        # Also capture command output to debug log
        debug_log "COMMAND OUTPUT:"
        tail -n 50 "${DOTFILES_LOG_FILE:-/tmp/bootstrap.log}" >> "$(get_debug_log_file)"
        debug_log "END COMMAND OUTPUT"
        
        info_log "Completed: $message"
        return 0
    else
        # Log failure details to debug log
        debug_log "COMMAND FAILED: $command"
        debug_log "ERROR OUTPUT:"
        tail -n 50 "${DOTFILES_LOG_FILE:-/tmp/bootstrap.log}" >> "$(get_debug_log_file)"
        debug_log "END ERROR OUTPUT"
        
        error_log "Failed: $message"
        return 1
    fi
}

# log_output is now provided by the logging module

# Show exit screen
show_exit_screen() {
    clear
    show_standard_header
    show_section_header "SYSTEM OPERATIONS"
    
    # Disconnection messages
    gum style --foreground "$INTERFACE_COLOR" "DISCONNECTING..."
    sleep 1
    ansi --newline
    gum style --foreground "$INTERFACE_SECONDARY" "/// SESSION TERMINATED [X]"
    ansi --newline
    
    exit 0
}